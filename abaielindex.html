<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Beescape — La Nature en 3D</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=DM+Sans:wght@300;400;500&display=swap');

    :root {
      --honey:   #F5A623;
      --amber:   #E07B00;
      --dark:    #1A1208;
      --cream:   #FFF8EC;
      --soft:    #FDEBD0;
      --brown:   #4A2E0A;
    }

    *, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }

    html { scroll-behavior: smooth; }

    body {
      background: var(--cream);
      color: var(--dark);
      font-family: 'DM Sans', sans-serif;
      overflow-x: hidden;
    }

    /* ── Canvas 3D ── */
    #three-canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100vh;
      z-index: 0;
      pointer-events: none;
    }

    /* ── Scrollable wrapper ── */
    #scroll-container {
      position: relative;
      z-index: 10;
      height: 400vh; /* 4 × viewport pour le scroll */
      pointer-events: none;
    }

    /* ── Sections UI ── */
    .section {
      position: sticky;
      top: 0;
      height: 100vh;
      display: flex;
      align-items: center;
      padding: 0 8vw;
      pointer-events: none;
    }

    .section--right { justify-content: flex-end; }

    .text-block {
      max-width: 380px;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity .6s ease, transform .6s ease;
      pointer-events: auto;
    }

    .text-block.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .eyebrow {
      font-family: 'DM Sans', sans-serif;
      font-size: .72rem;
      font-weight: 500;
      letter-spacing: .18em;
      text-transform: uppercase;
      color: var(--amber);
      margin-bottom: 12px;
    }

    h1, h2 {
      font-family: 'Playfair Display', serif;
      line-height: 1.15;
      color: var(--brown);
    }

    h1 { font-size: clamp(2.4rem, 5vw, 4rem); margin-bottom: 18px; }
    h2 { font-size: clamp(1.8rem, 3.5vw, 2.8rem); margin-bottom: 14px; }

    p {
      font-size: clamp(.9rem, 1.4vw, 1.05rem);
      line-height: 1.75;
      color: #5a3d18;
      font-weight: 300;
    }

    .pill {
      display: inline-block;
      margin-top: 22px;
      padding: 10px 24px;
      border: 1.5px solid var(--honey);
      border-radius: 100px;
      font-size: .82rem;
      font-weight: 500;
      letter-spacing: .06em;
      color: var(--amber);
      cursor: pointer;
      transition: background .25s, color .25s;
    }
    .pill:hover { background: var(--honey); color: #fff; }

    /* ── Progress bar ── */
    #progress-bar {
      position: fixed;
      top: 0; left: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--honey), var(--amber));
      width: 0%;
      z-index: 100;
      transition: width .1s linear;
    }

    /* ── Scroll hint ── */
    #scroll-hint {
      position: fixed;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      opacity: 1;
      transition: opacity .5s;
    }
    #scroll-hint span {
      font-size: .68rem;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--amber);
    }
    .arrow-down {
      width: 20px; height: 20px;
      border-right: 2px solid var(--honey);
      border-bottom: 2px solid var(--honey);
      transform: rotate(45deg);
      animation: bounce 1.4s infinite;
    }
    @keyframes bounce {
      0%,100% { transform: rotate(45deg) translateY(0); }
      50%      { transform: rotate(45deg) translateY(6px); }
    }

    /* ── Section 0 (Hero) ── */
    #s0 { align-items: center; justify-content: flex-start; }

    /* ── Background gradient overlay ── */
    .bg-gradient {
      position: fixed;
      inset: 0; z-index: 1;
      pointer-events: none;
      background: radial-gradient(ellipse 60% 70% at 50% 50%, transparent 40%, #FFF8ECCC 100%);
    }

    /* ── Hex deco ── */
    .hex-deco {
      position: fixed;
      top: 12vh; right: 6vw;
      opacity: .06;
      z-index: 2;
      pointer-events: none;
    }
    .hex-deco svg { width: 260px; height: 260px; }
  </style>
</head>
<body>

<!-- Canvas Three.js -->
<canvas id="three-canvas"></canvas>

<!-- Overlay gradient -->
<div class="bg-gradient"></div>

<!-- Hex déco -->
<div class="hex-deco">
  <svg viewBox="0 0 200 200" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M100 10 L180 55 L180 145 L100 190 L20 145 L20 55 Z" stroke="#F5A623" stroke-width="2"/>
    <path d="M100 30 L165 67.5 L165 132.5 L100 170 L35 132.5 L35 67.5 Z" stroke="#F5A623" stroke-width="1.5"/>
    <path d="M100 50 L150 80 L150 120 L100 150 L50 120 L50 80 Z" stroke="#F5A623" stroke-width="1"/>
  </svg>
</div>

<!-- Progress bar -->
<div id="progress-bar"></div>

<!-- Scroll hint -->
<div id="scroll-hint">
  <span>Scroll</span>
  <div class="arrow-down"></div>
</div>

<!-- Scrollable content -->
<div id="scroll-container">

  <!-- Section 0 : Hero -->
  <div class="section" id="s0">
    <div class="text-block" id="tb0">
      <div class="eyebrow">Bienvenue dans la ruche</div>
      <h1>L'abeille,<br/><em>gardienne</em><br/>du monde</h1>
      <p>Plongez dans l'univers fascinant des pollinisateurs. Faites défiler pour découvrir leur voyage.</p>
      <span class="pill">Explorer ↓</span>
    </div>
  </div>

  <!-- Section 1 -->
  <div class="section section--right" id="s1">
    <div class="text-block" id="tb1">
      <div class="eyebrow">Chapitre I — La mission</div>
      <h2>Un vol de 800 km pour une cuillère de miel</h2>
      <p>Chaque abeille butineuse parcourt des centaines de kilomètres au cours de sa vie, visitant jusqu'à 2 000 fleurs par jour. Un effort titanesque au service de la biodiversité.</p>
    </div>
  </div>

  <!-- Section 2 -->
  <div class="section" id="s2">
    <div class="text-block" id="tb2">
      <div class="eyebrow">Chapitre II — L'urgence</div>
      <h2>Un tiers de notre alimentation dépend d'elles</h2>
      <p>Sans pollinisateurs, les écosystèmes s'effondrent. Chaque geste compte : planter des fleurs sauvages, éviter les pesticides, préserver les haies.</p>
      <span class="pill">En savoir plus</span>
    </div>
  </div>

  <!-- Spacer final -->
  <div class="section" id="s3"></div>

</div>

<!-- Three.js r158 CDN -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

/* ═══════════════════════════════════════════
   SETUP
═══════════════════════════════════════════ */
const canvas  = document.getElementById('three-canvas');
const W = () => window.innerWidth;
const H = () => window.innerHeight;

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(W(), H());
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;

const scene = new THREE.Scene();
scene.background = null; // transparent → CSS cream

const camera = new THREE.PerspectiveCamera(45, W()/H(), 0.1, 200);
camera.position.set(0, 1.5, 8);
camera.lookAt(0, 0, 0);

/* ═══════════════════════════════════════════
   LUMIÈRES
═══════════════════════════════════════════ */
const ambientLight = new THREE.AmbientLight(0xfff4e0, 1.2);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffe0a0, 2.5);
sunLight.position.set(5, 8, 6);
sunLight.castShadow = true;
sunLight.shadow.mapSize.set(1024, 1024);
sunLight.shadow.camera.near = 0.5;
sunLight.shadow.camera.far = 40;
sunLight.shadow.camera.left = sunLight.shadow.camera.bottom = -6;
sunLight.shadow.camera.right = sunLight.shadow.camera.top = 6;
scene.add(sunLight);

const rimLight = new THREE.DirectionalLight(0xa0d8ef, 0.8);
rimLight.position.set(-4, 2, -5);
scene.add(rimLight);

const fillLight = new THREE.PointLight(0xf5a623, 1.2, 20);
fillLight.position.set(-2, 1, 4);
scene.add(fillLight);

/* ═══════════════════════════════════════════
   PARTICULES DE POLLEN
═══════════════════════════════════════════ */
const POLLEN_COUNT = 120;
const pollenGeo = new THREE.BufferGeometry();
const pPos = new Float32Array(POLLEN_COUNT * 3);
const pSpeeds = new Float32Array(POLLEN_COUNT);
for (let i = 0; i < POLLEN_COUNT; i++) {
  pPos[i*3]   = (Math.random() - .5) * 14;
  pPos[i*3+1] = (Math.random() - .5) * 8;
  pPos[i*3+2] = (Math.random() - .5) * 14;
  pSpeeds[i]  = .003 + Math.random() * .005;
}
pollenGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
const pollenMat = new THREE.PointsMaterial({ color: 0xf5a623, size: .06, transparent: true, opacity: .55 });
const pollenPoints = new THREE.Points(pollenGeo, pollenMat);
scene.add(pollenPoints);

/* ═══════════════════════════════════════════
   MODÈLE PROCÉDURAL BEE (fallback sans GLB)
═══════════════════════════════════════════ */
function buildProceduralBee() {
  const bee = new THREE.Group();

  // Matériaux
  const matBlack  = new THREE.MeshStandardMaterial({ color: 0x1a1208, roughness:.6, metalness:.1 });
  const matYellow = new THREE.MeshStandardMaterial({ color: 0xf5a623, roughness:.5, metalness:.05 });
  const matWing   = new THREE.MeshStandardMaterial({ color: 0xd0eeff, transparent:true, opacity:.55, roughness:.1, metalness:.2, side: THREE.DoubleSide });
  const matEye    = new THREE.MeshStandardMaterial({ color: 0x050505, roughness:.2, metalness:.5 });

  // Corps (abdomen + thorax fusionnés via segments)
  const segments = [
    { r:.38, c: matYellow, z:  0    },
    { r:.36, c: matBlack,  z:  .55  },
    { r:.34, c: matYellow, z:  1.05 },
    { r:.30, c: matBlack,  z:  1.50 },
    { r:.25, c: matYellow, z:  1.88 },
    { r:.18, c: matBlack,  z:  2.18 },
  ];
  segments.forEach(s => {
    const m = new THREE.Mesh(new THREE.SphereGeometry(s.r, 16, 10), s.c);
    m.position.z = -s.z;
    m.castShadow = true;
    bee.add(m);
  });

  // Tête
  const head = new THREE.Mesh(new THREE.SphereGeometry(.28, 14, 10), matBlack);
  head.position.set(0, 0, .62);
  head.castShadow = true;
  bee.add(head);

  // Yeux
  const eyeGeo = new THREE.SphereGeometry(.1, 8, 6);
  [-1,1].forEach(side => {
    const eye = new THREE.Mesh(eyeGeo, matEye);
    eye.position.set(side * .18, .12, .82);
    bee.add(eye);
  });

  // Antennes
  const antennaMat = new THREE.MeshStandardMaterial({ color: 0x1a1208, roughness:.7 });
  [-1,1].forEach(side => {
    const stem = new THREE.Mesh(new THREE.CylinderGeometry(.02, .02, .55, 6), antennaMat);
    stem.position.set(side * .12, .3, .85);
    stem.rotation.z = side * -.35;
    stem.rotation.x = -.5;
    bee.add(stem);
    const ball = new THREE.Mesh(new THREE.SphereGeometry(.055, 7, 5), matBlack);
    ball.position.set(side * .28, .58, .63);
    bee.add(ball);
  });

  // Dard
  const sting = new THREE.Mesh(new THREE.ConeGeometry(.06, .35, 7), matBlack);
  sting.position.set(0, 0, -2.42);
  sting.rotation.x = Math.PI/2;
  bee.add(sting);

  // Ailes (4)
  const wingGeo = new THREE.EllipseCurve(0,0, .85, .38, 0, Math.PI*2, false);
  const wingShape = new THREE.Shape(wingGeo.getPoints(32));
  const wingExtrudeGeo = new THREE.ShapeGeometry(wingShape, 12);

  const wingsData = [
    { x:  .55, y: .28, z: -.2,  ry: -.18, name:'wing_right_front' },
    { x:  .62, y: .22, z: -.9,  ry: -.18, name:'wing_right_back'  },
    { x: -.55, y: .28, z: -.2,  ry:  .18, name:'wing_left_front'  },
    { x: -.62, y: .22, z: -.9,  ry:  .18, name:'wing_left_back'   },
  ];
  wingsData.forEach(d => {
    const w = new THREE.Mesh(wingExtrudeGeo, matWing);
    w.position.set(d.x, d.y, d.z);
    w.rotation.set(-.3, d.ry, 0);
    w.name = d.name;
    bee.add(w);
  });

  // Pattes (6)
  const legMat = new THREE.MeshStandardMaterial({ color: 0x1a1208, roughness:.8 });
  for (let i = 0; i < 3; i++) {
    [-1,1].forEach(side => {
      const leg = new THREE.Mesh(new THREE.CylinderGeometry(.018, .012, .6, 5), legMat);
      leg.position.set(side * .38, -.28, -.3 - i * .42);
      leg.rotation.z = side * .7;
      leg.rotation.x = .4;
      bee.add(leg);
    });
  }

  // Fuzz (poils) — simulé via petits cylindres sur le thorax
  for (let i = 0; i < 18; i++) {
    const a = (i / 18) * Math.PI * 2;
    const fuzz = new THREE.Mesh(
      new THREE.CylinderGeometry(.01, .005, .12, 4),
      new THREE.MeshStandardMaterial({ color: 0xf5a623, roughness:1 })
    );
    fuzz.position.set(Math.cos(a)*.36, Math.sin(a)*.36, -.3);
    fuzz.rotation.z = a + Math.PI/2;
    bee.add(fuzz);
  }

  return bee;
}

/* ═══════════════════════════════════════════
   CHARGEMENT GLB (avec fallback procédural)
═══════════════════════════════════════════ */
let beeGroup = null;
let wingMeshes = [];
let mixer = null;

function onBeeLoaded(group) {
  beeGroup = group;
  beeGroup.scale.setScalar(1.4);
  beeGroup.rotation.y = Math.PI; // face à la caméra
  scene.add(beeGroup);

  // Chercher les meshes d'ailes pour animation manuelle si pas d'AnimationClip
  beeGroup.traverse(child => {
    if (child.isMesh) {
      child.castShadow = true;
      child.receiveShadow = true;
      const n = child.name.toLowerCase();
      if (n.includes('wing')) wingMeshes.push(child);
    }
  });

  console.log('✅ Bee loaded | wing meshes found:', wingMeshes.length);
}

// Tentative de chargement GLB
const loader = new GLTFLoader();
const draco  = new DRACOLoader();
draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/libs/draco/');
loader.setDRACOLoader(draco);

loader.load(
  './bee.glb',
  (gltf) => {
    if (gltf.animations && gltf.animations.length > 0) {
      mixer = new THREE.AnimationMixer(gltf.scene);
      gltf.animations.forEach(clip => mixer.clipAction(clip).play());
    }
    onBeeLoaded(gltf.scene);
  },
  undefined,
  (err) => {
    console.warn('bee.glb non trouvé → abeille procédurale utilisée', err);
    const bee = buildProceduralBee();
    onBeeLoaded(bee);
  }
);

/* ═══════════════════════════════════════════
   SPLINE DE TRAJECTOIRE
═══════════════════════════════════════════ */
const splinePath = new THREE.CatmullRomCurve3([
  new THREE.Vector3( 0,   1.5,  5),   // point 0% — devant
  new THREE.Vector3( 1.2, 0.8,  1),   // 33%
  new THREE.Vector3(-0.8, 0.2, -4),   // 66%
  new THREE.Vector3( 0,  -0.5, -9),   // 100% — loin
]);

/* ═══════════════════════════════════════════
   SCROLL STATE
═══════════════════════════════════════════ */
let scrollProgress = 0;
let targetScrollProgress = 0;

const scrollContainer = document.getElementById('scroll-container');

window.addEventListener('scroll', () => {
  const maxScroll = scrollContainer.scrollHeight - window.innerHeight;
  targetScrollProgress = Math.min(Math.max(window.scrollY / maxScroll, 0), 1);

  // Progress bar
  document.getElementById('progress-bar').style.width = (targetScrollProgress * 100) + '%';

  // Hide scroll hint after first scroll
  if (targetScrollProgress > 0.02) {
    document.getElementById('scroll-hint').style.opacity = '0';
  }

  // Text blocks visibility
  updateTextBlocks(targetScrollProgress);
});

function updateTextBlocks(p) {
  const blocks = [
    { id:'tb0', from:0,    to:0.22 },
    { id:'tb1', from:0.25, to:0.62 },
    { id:'tb2', from:0.62, to:1.00 },
  ];
  blocks.forEach(b => {
    const el = document.getElementById(b.id);
    const visible = p >= b.from && p <= b.to;
    el.classList.toggle('visible', visible);
  });
}

// Show hero text on load
setTimeout(() => updateTextBlocks(0), 300);
document.getElementById('tb0').classList.add('visible');

/* ═══════════════════════════════════════════
   ANIMATION LOOP
═══════════════════════════════════════════ */
const clock = new THREE.Clock();
let hoverPhase = 0;

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  const elapsed = clock.elapsedTime;

  // Smooth scroll progress (easing)
  scrollProgress += (targetScrollProgress - scrollProgress) * 0.08;

  if (beeGroup) {
    /* --- Position sur la spline --- */
    const pt = splinePath.getPoint(scrollProgress);
    beeGroup.position.lerp(pt, 0.06);

    /* --- Tangent → orientation naturelle --- */
    const tangent = splinePath.getTangent(Math.min(scrollProgress + 0.01, 1));
    const targetQuat = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 0, -1),
      tangent.clone().normalize()
    );
    beeGroup.quaternion.slerp(targetQuat, 0.05);

    /* --- Hover (monte/descend) --- */
    hoverPhase += dt * 1.8;
    beeGroup.position.y += Math.sin(hoverPhase) * 0.012;

    /* --- Animation des ailes (manuel) si pas de GLB mixer --- */
    if (!mixer) {
      const wingAngle = Math.sin(elapsed * 28) * 0.55;
      beeGroup.traverse(child => {
        if (!child.name) return;
        const n = child.name.toLowerCase();
        if (n.includes('wing_left'))  child.rotation.z = wingAngle;
        if (n.includes('wing_right')) child.rotation.z = -wingAngle;
      });
    }

    /* --- Légère rotation "vivante" --- */
    beeGroup.rotation.z = Math.sin(elapsed * .7) * 0.06;
  }

  if (mixer) mixer.update(dt);

  /* --- Pollen animation --- */
  const positions = pollenGeo.attributes.position.array;
  for (let i = 0; i < POLLEN_COUNT; i++) {
    positions[i*3+1] += pSpeeds[i];
    if (positions[i*3+1] > 5) positions[i*3+1] = -5;
    positions[i*3]   += Math.sin(elapsed + i) * .002;
  }
  pollenGeo.attributes.position.needsUpdate = true;

  /* --- Camera follow douce --- */
  if (beeGroup) {
    const camTarget = new THREE.Vector3(
      beeGroup.position.x * .3,
      beeGroup.position.y * .2 + 1.5,
      beeGroup.position.z + 8
    );
    camera.position.lerp(camTarget, 0.03);
    camera.lookAt(beeGroup.position);
  }

  renderer.render(scene, camera);
}

animate();

/* ═══════════════════════════════════════════
   RESPONSIVE RESIZE
═══════════════════════════════════════════ */
window.addEventListener('resize', () => {
  camera.aspect = W() / H();
  camera.updateProjectionMatrix();
  renderer.setSize(W(), H());
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
});
</script>
</body>
</html>
